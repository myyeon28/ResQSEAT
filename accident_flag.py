# -*- coding: utf-8 -*-
"""accident_flag

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pgn_IvTGe6JNCxDD1dbAagpH6nfTfG0X
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# accident_flag.py
# Description: Blocks execution until an impact (G-force) threshold is
# detected from the Arduino data.

import json, time
from pathlib import Path
from typing import Optional, Dict, Any

# Import the get_arduino_data module to get data from memory
try:
    import get_arduino_data
except ImportError:
    print("Error: Could not import get_arduino_data.py.")
    # Define a dummy function if import fails, so testing block can run
    def get_latest_seat_data():
        time.sleep(0.1)
        # Simulate a crash for testing
        if time.time() % 10 > 5:
             return {"S1":{"mpu_g":0.1}, "S2":{"mpu_g":0.2}, "S3":{"mpu_g":0.1}, "S4":{"mpu_g":0.1}}
        else:
             return {"S1":{"mpu_g":5.0}, "S2":{"mpu_g":0.2}, "S3":{"mpu_g":0.1}, "S4":{"mpu_g":0.1}}

# --- Settings ---
ACCIDENT_G_THRESH = 1.1 # The G-force threshold to trigger an accident
SEATS = ("S1", "S2", "S3", "S4")
POLL_INTERVAL = 0.01 # How often to check the in-memory data (fast)

def wait_accident_flag(timeout_s: Optional[float] = None,
                       thresh: float = ACCIDENT_G_THRESH) -> Optional[Dict[str, Any]]:
    """
    Blocks until any seat's mpu_g value exceeds the threshold.

    This function continuously polls the in-memory data from get_arduino_data.

    Args:
        timeout_s (Optional[float]): If set, returns None after this many seconds.
        thresh (float): The G-force threshold.

    Returns:
        Optional[Dict[str, Any]]: The 'seats' data dictionary that triggered
                                  the accident, or None if timed out.
    """
    deadline = (time.time() + timeout_s) if timeout_s is not None else None

    last_data_ts = None

    while True:
        # 1. Get the latest data from memory (very fast)
        seats_data = get_arduino_data.get_latest_seat_data()

        # 2. Check if data is valid
        if not seats_data or len(seats_data) < len(SEATS):
            # Wait for all Arduinos to report in
            time.sleep(0.1)
            continue

        # 3. Check for the accident trigger
        try:
            # Check the mpu_g value for all seats
            for seat_name in SEATS:
                mpu_g = float(seats_data.get(seat_name, {}).get("mpu_g", 0.0))

                if mpu_g > thresh:
                    # !! ACCIDENT DETECTED !!
                    # Return the *entire* seat data dictionary from the moment of impact
                    return seats_data

        except (ValueError, TypeError):
            # Data was invalid (e.g., None, "abc"), just skip this loop
            pass

        # 4. Check for timeout
        if deadline is not None and time.time() > deadline:
            return None # Timeout occurred

        # 5. Wait before polling again
        time.sleep(POLL_INTERVAL)

if __name__ == "__main__":
    print(f"Waiting for accident flag (G > {ACCIDENT_G_THRESH})... (10s timeout)")

    # Test with a 10-second timeout
    trigger_data = wait_accident_flag(timeout_s=10)

    if trigger_data:
        print("\n--- ACCIDENT DETECTED ---")
        print("Trigger data:")
        print(json.dumps(trigger_data, indent=2))
    else:
        print("\n--- TIMEOUT ---")
        print("No accident detected.")